# The goal overall goal of this project, is to create a program that outputs an
# orbit diagram. This part of the program will have the simple task of creating
# a list of the iterations, as it iterates them.
import math
import numpy as np
import matplotlib.pyplot as plt
from pylab import *

def iterate(r):
	#This will iterate the function and create a list of the fixed points or 
	#the periodic orbit.
	
	#keeps track of how many iterations have occured
	iteration = 0
	nthIterate = 3.14159265358
	#this is the variable that will change, and be logged in to a list
	#note that this will be the seed.
	
	fixedPoints = []
	orbit = []
	#If the answer can't be decided within a certain number of iterations the 
	#program will stop iterating
	inconclusive = False
	ordered = 0
	attractToZero = False
	while orbit.count(nthIterate) == 0:
		
		
		#add the iterate to the list
		orbit.append(nthIterate)
		
		
		#actual iteration
		#note that this line should be able to use any equation to iterate
		#currenlty this is the logistic equation, but again, it should be
		#able to use anything
		nthIterate = math.sin(nthIterate)*r
		iteration += 1
		

		
		if iteration >= 1000:
			inconclusive = True
			break
			
		if nthIterate == 0:
			attractToZero = True
			break
	
	if orbit.count(nthIterate) != 0 and iteration - orbit.index(nthIterate) == 1:
		fixedPoints.append(nthIterate)	
			
	#if the orbit is chaotic I don't want to use all 100000 points
	#instead I'm going to do 200
	
	elif inconclusive == True:
		fixedPoints = orbit[100: 300]
		
	elif attractToZero == True:
		fixedPoints.append(0)
		#print("Attracting to zero")
	else:
		fixedPoints = orbit[(orbit.index(nthIterate)):]
	
		
	return fixedPoints
def checkForPeriod(orbit):
	check = .0000000001
	beginningOfPeriod = 0
	endOfPeriod = len(orbit)
	for t in range(len(orbit)):
		for s in range(t + 1,len(orbit) , 1):
			if abs((orbit[t] - orbit[s])) <= check:
				check = abs(orbit[t] - orbit[s])
				if t >= 0:
					beginningOfPeriod = t
				if s <= len(orbit):
					endOfPeriod = s
	orbit = orbit[beginningOfPeriod:endOfPeriod]
	return orbit
				

	
	

i = -3.9999
fixedPoints = {}
xCoord = []
yCoord = []

#insure that orbits are periodic, or if they aren't it makes them
#periodic (unless they're chaotic)
while i < 3.9999:
#first the equation needs to be iterated
 	fixedPoints[i] = iterate(i)
 	print(fixedPoints[i])
 	if len(fixedPoints[i]) > 1 and len(fixedPoints[i]) < 10000:
 		fixedPoints[i] = checkForPeriod(fixedPoints[i])
 	xCoord.append(i)
 	
 	i += .0001
 	
 	
 	
 	

s = -3.9999
branch = 0
#draw the actual graph	
while s < 3.9999:
	if branch < len(fixedPoints[s]):
		yCoord.append(fixedPoints[s][branch])

	else:
		yCoord.append(fixedPoints[s][0])
		
	s += .0001
	index = s
	if s >= 3.9999:

		plt.plot(xCoord, yCoord, marker = '.', linestyle = 'None')
		branch += 1

		if branch <= len(fixedPoints[index - .0001]):
			s = -3.9999
			yCoord = []
	

	
plt.xlabel('r')
plt.ylabel('x')
plt.title('Figure 4:     Orbit Diagram for r * sin(x)')
plt.savefig("orbit.png")
plt.show()
